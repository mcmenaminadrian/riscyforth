.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RISCYFORTH" "" "August 2023" "" ""
.hy
.PP
RICSCYFORTH(1) RISCYFORTH MANUAL RISCYFORTH(1)
.SH NAME
.PP
riscyforth - Forth for RISC-V SBCs
.SH SYNOPSIS
.PP
riscyforth riscyforth [-h | -u] riscyforth -v riscyforth -i filepath
.SH DESCRIPTION
.PP
\f[B]riscyforth\f[R] is a 64-bit Forth for RISC-V single board
computers.
It is mostly written in RISC-V assembly and is free software with
modification and distribution (including of this man file) covered by
version 2 of the GNU General Public Licence (which should be found in
every distribution of \f[B]riscyforth\f[R]), or any later version, at
your discretion.
.PP
The most up-to-date version of \f[B]riscyforth\f[R] can be found at
https://github.com/mcmenaminadrian/riscyforth
.PP
Staring \f[B]riscyforth\f[R] will invoke a terminal interface and
programs may be loaded or written directly.
Persistent programs need to be written in an editor and loaded into a
running instance of \f[B]riscyforth\f[R].
.PP
This man file describes the words natively supported by
\f[B]riscyforth\f[R].
Like all Forths \f[B]riscyforth\f[R] may be extended through \f[I]colon
words\f[R] written in Forth itself.
.PP
\f[B]riscyforth\f[R] aims to support the Forth 2012 standard but not all
words here are part of the standard and not quite all of the standard is
(currently) supported.
.PP
It should be noted that \f[B]riscyforth\f[R] is a 64 bit Forth - i.e.,
cells are 8 bytes wide by default.
.PP
\f[B]riscyforth\f[R] is copyright (c) Adrian McMenamin, 2020 - 2024.
.SH OPTIONS
.IP
.nf
\f[C]
    -h, -u
        Show usage message

    -v
        Show verbose output (default is verbose output is suppressed).

    -i filepath
        Include Forth file found at filepath
\f[R]
.fi
.SH EXAMPLES
.IP
.nf
\f[C]
    riscyforth -i ./src/exceptions.fth
        Load the Forth exceptions code on startup from the src directory.
\f[R]
.fi
.SH FORTH WORDS
.PP
An alphabetical list of core Forth words implemented on
\f[B]riscyforth\f[R] follows.
A word in the Forth 2012 Core which is not yet implemented (and may
never be) is also noted for the convenience of those porting code.
.PP
\f[B]ABORT\f[R] Quit without displaying a message
.PP
\f[B]ABORT\[rq]\f[R] (x \[en]) if \f[I]x\f[R] is non-zero quit
displaying a message e.g., \f[I]1 ABORT\[rq] Display this message on
quitting\[rq]\f[R]
.PP
\f[B]ABS\f[R] (n \[en] u) Place the absolute value of \f[I]n\f[R] on the
stack
.PP
\f[B]ACCEPT\f[R] (addr n1 \[en] n2) Store at most \f[I]n1\f[R]
characters in buffer at address \f[I]addr\f[R], \f[I]n2\f[R] is the
actual number of characters stored
.PP
\f[B]ACTION-OF\f[R] (\[en] xt) At run time returns the execution token
\f[I]xt\f[R] for the deferred word eg., to use \f[I]ACTION-OF
TESTDEFER\f[R]
.PP
\f[B]AGAIN\f[R] Return to the code block marked by \f[I]BEGIN\f[R]
.PP
\f[B]ALIGN\f[R] (\[en]) If required (8-byte) align the data space
pointer
.PP
\f[B]ALIGNED\f[R] (a1 \[en] a2) \f[I]a2\f[R] is the first aligned
address greater than or equal to \f[I]a1\f[R]
.PP
\f[B]ALLOCATE\f[R] (u \[en] addr ior) allocate \f[I]u\f[R] bytes at
address \f[I]addr\f[R]
.PP
\f[B]ALLOT\f[R] (n \[en]) move the data space pointer by \f[I]n\f[R]
bytes
.PP
\f[B]AND\f[R] (x1 x2 \[en] x3) \f[I]x3\f[R] is the bitwise logical
\f[I]AND\f[R] of \f[I]x1\f[R] with \f[I]x2\f[R]
.PP
\f[B]BASE\f[R] (\[en] a) \f[I]a\f[R] is the address of the current
number conversion radix (number base)
.PP
\f[B]BBLACK\f[R] Set terminal background to black
.PP
\f[B]BBLUE\f[R] Set terminal background to blue
.PP
\f[B]BCYAN\f[R] Set terminal background to cyan
.PP
\f[B]BEGIN\f[R] Begins a loop code block
.PP
\f[B]BGREEN\f[R] Sets terminal background to green
.PP
\f[B]BINARY\f[R] Set the radix (base) to two
.PP
\f[B]BL\f[R] (\[en] c) Places the value 0x20 (ascii 32 - space) on the
stack
.PP
\f[B]BLACK\f[R] Set terminal foreground to black
.PP
\f[B]BLUE\f[R] Set terminal foreground to blue
.PP
\f[B]BMAGENTA\f[R] Set terminal background to magenta
.PP
\f[B]BRED\f[R] Set terminal background to red
.PP
\f[B]BRIGHT\f[R] Set terminal output to bright
.PP
\f[B]BUFFER:\f[R] (x \[en] a) Creates a buffer of length x that returns
address \f[I]a\f[R] e.g., \f[I]80 BUFFER: TESTBUF\f[R] creates the
buffer \f[I]TESTBUF\f[R] of length 80 bytes
.PP
\f[B]BWHITE\f[R] Set terminal background to white
.PP
\f[B]BYE\f[R] Leave \f[B]riscyforth\f[R]
.PP
\f[B]BYELLOW\f[R] Set terminal background to yellow
.PP
\f[B][\f[R] At compile time the contents of \f[I][ ]\f[R] are
immediately evaluated
.PP
\f[B][CHAR]\f[R] (\[lq]spaces<name>\[rq] \[en]) At runtime: (\[en] char)
Places value of first character in \f[I]name\f[R] on stack as
\f[I]char\f[R]
.PP
\f[B][COMPILE]\f[R] NOT IMPLEMENTED: Word is obsolescent in Forth 2012.
Use \f[I]POSTPONE\f[R] instead.
.PP
\f[B][\[cq]]\f[R] (\[lq]spaces\[rq]<name>\[rq] \[en]) At runtime: (\[en]
xt) Please use \f[I]\[cq]\f[R] instead (\f[I][\[cq]]\f[R] has the same
functionality)
.PP
\f[B]CASE\f[R] Mark the start of \f[I]CASE ..
OF ..
ENDOF ..
ENDCASE\f[R] control structure
.PP
\f[B]C,\f[R] (c \[en]) Advance data space pointer by 1 and store
\f[I]c\f[R] in data space
.PP
\f[B]CELL+\f[R] (a1 \[en] a2) add a cell size (8 bytes) to \f[I]a1\f[R]
and store sum \f[I]a2\f[R] on the stack
.PP
\f[B]CELLS\f[R] (n1 \[en] n2) store the size, \f[I]n2\f[R] of
\f[I]n1\f[R] cells on the stack
.PP
\f[B]C\[at]\f[R] (c-addr \[en] char) Fetch the character stored at
\f[I]c-addr\f[R] and store on the stack as \f[I]char\f[R]
.PP
\f[B]CHAR\f[R] (\[lq]name\[rq] \[en] char) Put the first character of
the string \f[I]name\f[R] on the stack as \f[I]char\f[R]
.PP
\f[B]CHAR+\f[R] (caddr1 \[en] caddr2) Add character size (1) to address
\f[I]caddr1\f[R] and store result on stack in \f[I]caddr2\f[R]
.PP
\f[B]CHARS\f[R] (n1 \[en] n2) \f[I]n2\f[R] is the size in address units
of \f[I]n1\f[R] (this is a NOP)
.PP
\f[B]COMPILE,\f[R] (xt \[en]) At compile time \f[I]xt\f[R] is compiled
in (replacing \f[I]COMPILE,\f[R])
.PP
\f[B]CONSTANT\f[R] Create a word that returns a constant value to the
stack e.g., \f[I]25 FIVESQUARED CONSTANT\f[R] creates the constant
\f[I]FIVESQUARED\f[R] that will always return 25 on the stack
.PP
\f[B]COUNT\f[R] (c-addr1 \[en] c-addr2 u) Return character count and
text address for counted string
.PP
\f[B]CR\f[R] (\[en]) output a newline
.PP
\f[B]CREATE\f[R] Create a word that returns a constant pointer to the
data space e.g., \f[I]CREATE TEST\f[R] creates the word \f[I]TEST\f[R]
that returns the value of the data space pointer at the time of
creation.
.PP
\f[B]C!\f[R] (char caddr \[en]) Stores character \f[I]char\f[R] at
\f[I]caddr\f[R]
.PP
\f[B]CYAN\f[R] Set termainal foreground to cyan
.PP
\f[B]:\f[R] Begin a \f[I]colon word\f[R] definition
.PP
\f[B]:NONAME\f[R] (\[en] xt) Create a \f[I]colon-word\f[R] and place
execution token \f[I]xt\f[R] on stack
.PP
\f[B],\f[R] (x \[en]) Advance data space pointer by one cell and store
\f[I]x\f[R] in the cell
.PP
\f[B]C\[rq]\f[R] (\[en] c-addr) on execution, (\[lq]ccc\[rq] \[en]) on
compilation.
Return counted string at address \f[I]c-addr\f[R] - compiled code only.
Does nothing in intrepreted code.
.PP
\f[B]CRESET\f[R] (mask addr \[en]) Turn bits off at \f[I]addr\f[R] using
8-bit \f[I]mask\f[R]
.PP
\f[B]CROSSEDOUT\f[R] ( \[em] ) Cross out text
.PP
\f[B]CSET\f[R] (mask addr \[en]) Set bits at \f[I]addr\f[R] using 8-bit
\f[I]mask\f[R]
.PP
\f[B]CTOGGLE\f[R] (mask addr \[en]) Toggle bits at \f[I]addr\f[R] using
8-bit \f[I]mask\f[R]
.PP
\f[B]CUBE\f[R] (x1 \[en] x2) Cube \f[I]x1\f[R] and store in \f[I]x2\f[R]
.PP
\f[B]DECIMAL\f[R] Set radix (base) to ten
.PP
\f[B]DEFER\f[R] Defer execution of created word to another word e.g.,
\f[I]DEFER TEST\f[R] creates a word \f[I]TEST\f[R] that we can later
assign execution characteristics to (see e.g., \f[I]DEFER\[at]\f[R])
.PP
\f[B]DEFER\[at]\f[R] (x1 \[en] x2) Reports that execution token
\f[I]x1\f[R] is set to \f[I]x2\f[R] e.g., \f[I]EMIT IS TESTDEFER \[cq]
TESTDEFER DEFER\[at] \[cq] EMIT =\f[R] will return \f[I]TRUE\f[R] if a
call to \f[I]TESTDEFER\f[R] executes \f[I]EMIT\f[R]
.PP
\f[B]DEFER!\f[R] (x2 x1 \[en]) will set execution token \f[I]x1\f[R] to
\f[I]x2\f[R] e.g., \f[I]\[cq] EMIT \[cq] TESTDEFER DEFER!\f[R] will set
\f[I]TESTDEFER\f[R] to execute \f[I]EMIT\f[R]
.PP
\f[B]DEPTH\f[R] (\[en] n) Reports depth of stack
.PP
\f[B]DISPLAY\f[R] (x..x \[en] x..x) will display zero terminated string
built from stack
.PP
\f[B]DO\f[R] Begins \f[I]LOOP\f[R] block in form: \f[I]limit first DO
\&...
LOOP\f[R] (or \f[I]+LOOP\f[R] or \f[I]-LOOP\f[R])
.PP
\f[B]DOES>\f[R] Assigns execution body to word created in data space
e.g., \f[I]: INDEXED-ARRAY CREATE CELLS ALLOT DOES> SWAP CELLS + ;\f[R]
creates an indexed array type
.PP
\f[B]DROP\f[R] (x \[en])
.PP
\f[B]DUP\f[R] (x \[en] x x)
.PP
\f[B]/\f[R] (n1 n2 \[en] n3) Divide \f[I]n1\f[R] by \f[I]n2\f[R] and
store the result on the stack as \f[I]n3\f[R]
.PP
\f[B]/MOD\f[R] (n1 n2 \[en] n3 n4) Divide \f[I]n1\f[R] by \f[I]n2\f[R],
storing the remainder \f[I]n3\f[R] and the quotient \f[I]n4\f[R] on the
stack
.PP
\f[B].R\f[R] (n1 n2 \[en]) Display \f[I]n1\f[R] right flushed in a field
of width \f[I]n2\f[R]
.PP
\f[B].S\f[R] Debug word that displays contents of stack
.PP
\f[B].(\f[R] (\[lq]ccc\[rq] \[en]) Parse and display ccc - immediate
word
.PP
\f[B].\[rq]\f[R] Output the enclosed string e.g.\ \f[I].\[rq] Output
this\[rq]\f[R]
.PP
\f[B]DROPINPUT\f[R] Discard rest of input line
.PP
\f[B]ELSE\f[R] \f[I]ELSE\f[R] clause in \f[I]IF ..
ELSE ..
THEN\f[R]
.PP
\f[B]EMIT\f[R] (x \[en]) Output character of value \f[I]x\f[R]
.PP
\f[B]ENDCASE\f[R] Mark the end of \f[I]CASE ..
OF ..
ENDOF ..
ENDCASE\f[R] control structure
.PP
\f[B]ENDOF\f[R] Mark the end of \f[I]OF ..
ENDOF\f[R] clause in \f[I]CASE ..
ENDCASE\f[R] control structure
.PP
\f[B]ENVIRONMENT?\f[R] (addr u \[en] false | i * x true) Query the local
environment.
\f[I]addr\f[R] and \f[I]u\f[R] are the address and length of a query
string.
Returns false if query is not supported, otherwise an answer based on
the query.
Currently supported query words: /COUNTED-STRING /HOLD /PAD
ADDRESS-UNIT-BITS FLOORED MAX-CHAR MAX-D MAX-N MAX-U MAX-UD
RETURN-STACK-CELLS STACK-CELLS
.PP
\f[B]ERASE\f[R] (addr u \[en]) if \f[I]u\f[R] greater than zero, clear
(set to zero) \f[I]u\f[R] bytes from address \f[I]addr\f[R]
.PP
\f[B]EVALUATE\f[R] ( i * x c-addr u \[en] j * x ) Interpret the string
at \f[I]c-addr\f[R]
.PP
\f[B]EXECUTE\f[R] (xt \[en] ?)
Remove \f[I]xt\f[R] from stack and execute it
.PP
\f[B]EXIT\f[R] Leave an \f[I]IF ..
ELSE ..
THEN\f[R] structure (care must be taken to \f[I]UNLOOP\f[R] if
necessary)
.PP
\f[B]=\f[R] (x1 x2 \[en] flag) Set \f[I]flag\f[R] to \f[I]TRUE\f[R] (-1)
if \f[I]x1 = x2\f[R] otherwise set \f[I]flag\f[R] to \f[I]FALSE\f[R]
(zero)
.PP
\f[B]FALSE\f[R] (\[en] 0) Zero indicating logical false
.PP
\f[B]FILL\f[R] (c-addr u char \[en]) if \f[I]u\f[R] is greater than zero
set \f[I]u\f[R] bytes from \f[I]c-addr\f[R] onwards to \f[I]char\f[R]
.PP
\f[B]FIND\f[R] (c-addr \[en] caddr 0 | xt 1 | xt -1) Find the definition
named in the counted string at c-addr.
If the definition is not found, return c-addr and zero.
If the definition is found, return its execution token xt.
If the definition is immediate, also return one (1), otherwise also
return minus-one (-1).
.PP
\f[B]FM/MOD\f[R] (d n2 \[en] n1 n0) Floored division: divide \f[I]d\f[R]
by \f[I]n2\f[R] and report remainder in \f[I]n1\f[R] and floored
quotient in \f[I]n0\f[R]
.PP
**\[at]** (addr \[en] x) Fetch as \f[I]x\f[R] the contents of cell at
\f[I]addr\f[R] and store on the stack
.PP
\f[B]FREE\f[R] (addr \[en] ior) Free memory at \f[I]addr\f[R]
(\f[I]ior\f[R] is zero on success)
.PP
\f[B]GETLINE\f[R] Fetch text input
.PP
\f[B]GREEN\f[R] Set terminal foreground to green
.PP
\f[B]HERE\f[R] (\[en] addr) Return the current value of the data space
pointer
.PP
\f[B]HEX\f[R] Set the radix (base) to sixteen
.PP
\f[B]HOLD\f[R] (char \[en]) Add \f[I]char\f[R] to the beginning of a
pictured numeric output string
.PP
\f[B]HOLDS\f[R] (caddr u \[en]) Add counted string defined by
\f[I]u\f[R] and \f[I]caddr\f[R] to the start of pictured numeric output
.PP
\f[B]I\f[R] (\[en] n) Place the value of the current innermost loop
counter on the stack
.PP
\f[B]IF\f[R] (x \[en]) Begin \f[I]IF \&...
ELSE ..
THEN\f[R] structure.
\f[I]IF\f[R] clause is executed if \f[I]x\f[R] is non-zero, otherwise
\f[I]ELSE\f[R] clause (if present) is executed.
.PP
\f[B]IMMEDIATE\f[R] (\[en]) Make the most recent definition an immediate
word
.PP
\f[B]INCLUDE\f[R] Load file and immediately parse e.g.
\f[I]INCLUDE /home/foo/bar.fth\f[R] will load and evaluate
\f[I]bar.fth\f[R]
.PP
\f[B]INVERT\f[R] (x1 \[en] x2) Invert all bits of \f[I]x1\f[R] and store
on the stack as \f[I]x2\f[R]
.PP
\f[B]IS\f[R] (xt \[en]) Set \f[I]name\f[R] to execute \f[I]xt\f[R] e.g.,
\f[I]\[cq] .
IS TESTDEFER\f[R] will ensure \f[I]TESTDEFER\f[R] executes \f[I].\f[R]
.PP
\f[B]J\f[R] (\[en] n) Place the value of the next-outer loop counter on
the stack
.PP
\f[B]KEY\f[R] (\[en] char) Receive one character from the (ASCII)
chaarcter set.
.PP
\f[B]LEAVE\f[R] R:(n \[en]) Immediately leave a loop discarding control
parameters
.PP
\f[B]LITERAL\f[R] (\[en] x) Place \f[I]x\f[R] on the stack e.g.\ \f[I][
x ] LITERAL\f[R]
.PP
\f[B]LOADMODULE\f[R] (\[lq]<spaces>name\[rq] \[en] x) Load the module
\f[I]name\f[R], leave \f[I]TRUE\f[R] on stack on success
.PP
\f[B]LOOP\f[R] Evaluate loop parameters and either terminate loop R:(x
\[en]) or continue to execute loop R:(x1 \[en] x2)
.PP
\f[B]LSHIFT\f[R] (x1 u \[en] x2) left shift \f[I]x1\f[R] by \f[I]u\f[R]
and store as \f[I]x2\f[R]
.PP
\f[B]MAGENTA\f[R] Set terminal foreground to magenta
.PP
\f[B]MARKER\f[R] (\[lq]name\[rq] \[en]) Delete everything in the
dictionary up to and including name
.PP
\f[B]MAX\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the greater of
\f[I]n1\f[R] and \f[I]n2\f[R]
.PP
\f[B]MAXINT\f[R] (\[en] n) Puts 0x7FFFFFFFFFFFFFFF on the stack
.PP
\f[B]MIN\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the lesser of
\f[I]n1\f[R] and \f[I]n2\f[R]
.PP
\f[B]MININT\f[R] (\[en] n) Puts 0x8000000000000000 on the stack
.PP
\f[B]-LOOP\f[R] (n \[en]) R:(x \[en] x1) Subtract \f[I]n\f[R] from
\f[I]x\f[R] and check loop limits
.PP
\f[B]-ROT\f[R] (x2 x1 x0 \[en] x0 x2 x1)
.PP
\f[B]MOD\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the remainder of dividing
\f[I]n1\f[R] by \f[I]n2\f[R]
.PP
\f[B]MOVE\f[R] (addr1 addr2 u \[en]) if \f[I]u\f[R] is greater than zero
copy \f[I]u\f[R] bytes from \f[I]addr1\f[R] to \f[I]addr2\f[R]
.PP
\f[B]M*\f[R] (n n \[en] d) Signed multiplication producing double (128
bit) result
.PP
\f[B]-\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the result of \f[I]n1\f[R]
minus \f[I]n2\f[R]
.PP
\f[B]MS\f[R] (x \[en]) Pause execution for \f[I]x\f[R] milliseconds
.PP
\f[B]NEGATE\f[R] (n1 \[en] n2) \f[I]n2\f[R] is the arithmetic inverse of
\f[I]n1\f[R]
.PP
\f[B]NIP\f[R] (x1 x2 \[en] x2)
.PP
\f[B]OCTAL\f[R] Set radix (base) to eight
.PP
\f[B]OF\f[R] From \f[I]CASE \&...
OF \&...
ENDOF ..
ENDCASE\f[R] structure
.PP
\f[B]OR\f[R] (x1 x2 \[en] x3) \f[I]x3\f[R] is bitwise inclusive or of
\f[I]x1\f[R] with \f[I]x2\f[R]
.PP
\f[B]OVER\f[R] (x1 x2 \[en] x1 x2 x1)
.PP
\f[B]1-\f[R] (x1 \[en] x2) Subtract 1 from \f[I]x1\f[R] and store the
result in \f[I]x2\f[R]
.PP
\f[B]1+\f[R] (x1 \[en] x2) Add 1 to \f[I]x1\f[R] and store the result in
\f[I]x2\f[R]
.PP
\f[B]PAD\f[R] (\[en] addr) return the address of a transient scratch pad
.PP
\f[B]PAGE\f[R] Clear the terminal and set output to the top left
.PP
\f[B]PARSE-NAME\f[R] ( \[lq]name\[rq] \[en] c-addr u ) Skip leading
space delimiters.
Parse name delimited by a space.
.PP
\f[B]PARSE\f[R] ( char \[lq]ccc\[rq] \[en] c-addr u ) Parse ccc
delimited by the delimiter .char
.PP
\f[B]PICK\f[R] (xu \&...
x1 x0 u \[en] x1 x0 xu)
.PP
\f[B]POSTPONE\f[R] (\[lq]<spaces>name\[rq] \[en]) Compile in
\f[I]name\f[R] even if \f[I]IMMEDIATE\f[R] - in general append the
compilation semantics of \f[I]name\f[R] to the current colon definition.
.PP
\f[B]+\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the sum of \f[I]n1\f[R] and
\f[I]n2\f[R]
.PP
\f[B]+LOOP\f[R] (n \[en]) R:(x \[en] x1) Add \f[I]n\f[R] to \f[I]x\f[R]
and check loop limits
.PP
\f[B]+!\f[R] (n addr \[en]) add \f[I]n\f[R] to the value stored in the
cell at \f[I]addr\f[R]
.PP
\f[B]?\f[R] (addr \[en]) Output value stored at address \f[I]addr\f[R]
.PP
\f[B]QUIT\f[R] Leave the executing program
.PP
\f[B]RDROP\f[R] R:(x \[en])
.PP
\f[B]RECURSE\f[R] Re-execute the current word
.PP
\f[B]RED\f[R] Set terminal forground to red
.PP
\f[B]REFILL\f[R] (\[en] flag) Currently just places 0xFFFFFFFFFFFFFFFF
(TRUE) on stack
.PP
\f[B]REPEAT\f[R] End of a \f[I]BEGIN ..
WHILE ..
REPEAT\f[R] block
.PP
\f[B]RESET\f[R] Reset the terminal colours
.PP
\f[B]RESIZE\f[R] (addr1 u \[en] addr2 ior) Copy data at \f[I]addr1\f[R]
to new area of size \f[I]u\f[R] which will be found at \f[I]addr2\f[R]
.PP
\f[B]RESTORE-INPUT\f[R] (xn ..
x1 n \[en] flag) Currently shortens stack by \f[I]n\f[R] entries and
posts TRUE (0xFFFFFFFFFFFFFFFF) only
.PP
\f[B]R\[at]\f[R] (\[en]x) R:(x \[en] x) Copy x from the return stack to
the (data) stack
.PP
\f[B]ROLL\f[R] (xu xu-1 ..
x1 x0 u \[en] xu-1 ..
x1 x0 xu)
.PP
\f[B]ROT\f[R] (x1 x2 x3 \[en] x2 x3 x1)
.PP
\f[B]RSHIFT\f[R] (x1 u \[en] x2) Logically right shift \f[I]x1\f[R] by
\f[I]u\f[R] and store in \f[I]x2\f[R]
.PP
\f[B]R>\f[R] (\[en]x) R:(x\[en]) Move \f[I]x\f[R] from the return stack
to the (data) stack
.PP
\f[B]SAVE-INPUT\f[R] (\[en] 0) Added for completness: merely puts a zero
on the stack.
.PP
\f[B]SIGN\f[R] (n \[en]) if \f[I]n\f[R] is negative add a minus sign to
the beginning of the pictured numeric output string
.PP
\f[B]SM/REM\f[R] (d n2 \[en] n1 n0) Symmetric division: divide
\f[I]d\f[R] by \f[I]n2\f[R] and report remainder in \f[I]n1\f[R] and
symmetric quotient \f[I]n0\f[R]
.PP
\f[B]SOURCE-ID\f[R] (\[en] 0|-1) Places 0 on stack for user-input device
source and -1 for string (via \f[I]EVALUATE\f[R])
.PP
\f[B]SOURCE\f[R] (\[en] addr u) \f[I]addr\f[R] is the address of the
input buffer and \f[I]u\f[R] the number of caharcters it contains
.PP
\f[B]SPACE\f[R] Display one space
.PP
\f[B]SPACES\f[R] (x \[en]) Display \f[I]x\f[R] spaces
.PP
\f[B]SQUARE\f[R] (x1 \[en] x2) Square \f[I]x1\f[R] and store in
\f[I]x2\f[R]
.PP
\f[B]STATE\f[R] (\[en] addr)
\f[I]a\f[R]\f[I]d\f[R]\f[I]d\f[R]\f[I]r\f[R] is the address of a cell
reporting the compilation state
.PP
\f[B]SWAP\f[R] (x1 x2 \[en] x2 x1)
.PP
\f[B];\f[R] Mark the end of a \f[I]colon word\f[R]
.PP
**S\[rs]\[lq]** At compilation: (\[rq]ccc\[rq] \[em]) Parse string ccc
At runtime: (\[en] c-addr u) Address and length of parsed string
.PP
\f[B]S\[rq]\f[R] (\[en] addr u) \f[I]addr\f[R] contains the address of,
and \f[I]u\f[R] the length of, the string defined in the inverted commas
.PP
\f[B]S>D\f[R] (n \[en] d) Convert \f[I]n\f[R] to double \f[I]d\f[R]
.PP
\f[B]!\f[R] (x addr \[en]) Store \f[I]x\f[R] at \f[I]addr\f[R]
.PP
\f[B]TERMIOSSTRING\f[R] (ccc\[rq]string\[rq] \[em] ?)
Interperet string as the body of a termnal escape sequence
.PP
\f[B]THEN\f[R] Final clause in all \f[I]IF\&...\f[R] structures,
execution continues after \f[I]THEN\f[R] once \f[I]IF\f[R] and
\f[I]ELSE\f[R] clauses exhausted
.PP
\f[B]TIB\f[R] (\[en] addr) Returns address of input buffer
.PP
\f[B]TIME&DATE\f[R] (\[en] n1 n2 n3 n4 n5 n6) \f[I]n1\f[R] is wall clock
second, \f[I]n2\f[R] minute, \f[I]n3\f[R] hour, \f[I]n4\f[R] day,
\f[I]n5\f[R] month, \f[I]n6\f[R] year
.PP
\f[B]TO\f[R] (x \[en]) Set a \f[I]VALUE\f[R] to \f[I]x\f[R]
.PP
\f[B]TRUE\f[R] (\[en] -1) Logical \f[I]TRUE\f[R] flag (-1)
.PP
\f[B]TUCK\f[R] (x2 x1 \[en] x1 x2 x1)
.PP
\f[B]TYPE\f[R] (addr u \[en]) Display the character string of length
\f[I]u\f[R] at address \f[I]addr\f[R]
.PP
\f[B]TYPEPROMPT\f[R] Display \f[I]>\f[R]
.PP
\f[B]\[cq]\f[R] (\[en] xt) Get the execution token for the word named
e.g., \f[I]\[cq] EMIT\f[R]
.PP
\f[B]*\f[R] (n1 n2 \[en] n3) \f[I]n3\f[R] is the product of \f[I]n1\f[R]
\f[I]n2\f[R]
.PP
\f[B]*/\f[R] (n1 n2 n3 \[en] n4) \f[I]n4\f[R] is \f[I]n1\f[R] times
\f[I]n2\f[R] divided by \f[I]n3\f[R]
.PP
\f[B]*/MOD\f[R] (n1 n2 n3 \[en] n4 n5) \f[I]n4\f[R] is the remainder of
\f[I]n1\f[R] times \f[I]n2\f[R] divided by \f[I]n3\f[R] and \f[I]n5\f[R]
is the quotient
.PP
\f[B]2DROP\f[R] (n1 n2 \[en])
.PP
\f[B]2DUP\f[R] (x1 x2 \[en] x1 x2 x1 x2)
.PP
\f[B]2/\f[R] (x1 \[en] x2) \f[I]x2\f[R] is x1 divided by 2
.PP
\f[B]2\[at]\f[R] (addr \[en] x1 x2) Fetch the two cells at
\f[I]addr\f[R] (stored in \f[I]x2\f[R]) and \f[I]addr + 8\f[R] (stored
in \f[I]x1\f[R])
.PP
\f[B]2OVER\f[R] (x1 x2 x3 x4 \[en] x1 x2 x3 x4 x1 x2)
.PP
\f[B]2RDROP\f[R] R:(x1 x2 \[en])
.PP
\f[B]2R\[at]\f[R] (\[en] x1 x2) R:(x1 x2 \[en] x1 x2) copy two top
entries on the return stack to the (data) stack
.PP
\f[B]2-\f[R] (x0 \[en] x1) Subtract 2 from \f[I]x0\f[R] and store in
\f[I]x1\f[R]
.PP
\f[B]2NIP\f[R] (x4 x3 x2 x1 x0 \[en] x4 x1 x0)
.PP
\f[B]2+\f[R] (x0 \[en] x1) Add 2 to \f[I]x0\f[R] and store in
\f[I]x1\f[R]
.PP
\f[B]2R>\f[R] (\[en] x1 x2) R:(x1 x2 \[en]) move top two entries on the
return stack to the (data) stack
.PP
\f[B]2ROT\f[R] (x5 x4 x3 x2 x1 x0 \[en] x3 x2 x1 x0 x5 x4)
.PP
\f[B]2SWAP\f[R] (x1 x2 x3 x4 \[en] x3 x4 x1 x2)
.PP
\f[B]2TUCK\f[R] (x3 x2 x1 x0 \[en] x1 x0 x3 x2 x1 x0)
.PP
\f[B]2!\f[R] (x1 x2 addr \[en]) store \f[I]x2\f[R] at \f[I]addr\f[R] and
\f[I]x1\f[R] at \f[I]addr + 8\f[R]
.PP
\f[B]2*\f[R] (x1 \[en] x2) \f[I]x2\f[R] is \f[I]x1\f[R] times 2
.PP
\f[B]2>R\f[R] (x1 x2) R:(\[en] x1 x2) move the top two entries on the
(data) stack to the return stack
.PP
\f[B]U.R\f[R] ( u n \[en] ) Display \f[I]u\f[R] right aligned in a field
\f[I]n\f[R] characters wide.
.PP
\f[B]UM/MOD\f[R] (ud u1 \[en] u2 u3) Divide \f[I]ud\f[R] by \f[I]u1\f[R]
giving quotient \f[I]u3\f[R] and remainder \f[I]u2\f[R] - all arithmetic
is unsigned
.PP
\f[B]UM*\f[R] (u1 u2 \[en] ud) Multipy \f[I]u1\f[R] by \f[I]u2\f[R] and
store result in \f[I]ud\f[R] - all arithmetic is unsigned
.PP
\f[B]+UNDER\f[R] (x2 x1 x0 \[en] x1 x3) \f[I]x3\f[R] is the sum of
\f[I]x2\f[R] and \f[I]x0\f[R]
.PP
\f[B]UNDERLINE\f[R] ( \[em] ) Underline output text
.PP
\f[B]UNLOOP\f[R] Discard the loop parameters for the current loop
(before \f[I]EXIT\f[R])
.PP
\f[B]UNTIL\f[R] (x \[en]) if \f[I]x\f[R] is zero return to code block
starting with \f[I]BEGIN\f[R]
.PP
\f[B]UNUSED\f[R] (\[en] u) Amount of space remaining in the region
addressed by \f[I]HERE\f[R]
.PP
\f[B]U.\f[R] (u \[en]) display \f[I]u\f[R] as an unsigned number
.PP
\f[B]VALUE\f[R] A value is a word proxy for a number e.g.
\f[I]7 VALUE SEVEN\f[R] assigns 7 to the word \f[I]SEVEN\f[R]
.PP
\f[B]VARIABLE\f[R] A variable is word proxy for a memory address -
accessed via \f[I]!\f[R] and *\[at]*
.PP
\f[B]WHILE\f[R] (x \[en]) if \f[I]x\f[R] is non-zero execute the code in
a \f[I]WHILE ..
REPEAT\f[R] block
.PP
\f[B]WHITE\f[R] Set terminal foreground to white
.PP
\f[B]WITHIN\f[R] (x1 x2 x3 \[en] flag) \f[I]flag\f[R] returns
\f[I]TRUE\f[R] if \f[I]x1\f[R] is between \f[I]x2\f[R] and \f[I]x3\f[R]
.PP
\f[B]WORD\f[R] ( char \[lq]ccc\[rq] \[en] c-addr ) Skip leading
delimiters.
Parse characters ccc delimited by char (512 max length)
.PP
\f[B]WORDS\f[R] Lists supported Forth words
.PP
\f[B]XOR\f[R] (x1 x2 \[en] x3) \f[I]x3\f[R] is the results of the
exclusive-or of \f[I]x1\f[R] with \f[I]x2\f[R]
.PP
\f[B]YELLOW\f[R] Set terminal foreground to yellow
.PP
\f[B]0=\f[R] (x \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x\f[R] is zero (otherwise \f[I]FALSE\f[R])
.PP
\f[B]0<\f[R] (x \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x\f[R] is less than zero (otherwise \f[I]FALSE\f[R])
.PP
\f[B]0>\f[R] (x \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x\f[R] is greater than zero (otherwise \f[I]FALSE\f[R])
.PP
\f[B]0<>\f[R] (x \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x\f[R] is not equal to zero (otherwise \f[I]FALSE\f[R])
.PP
\f[B]\[rs]\f[R] The rest of the line is treated as a comment and is not
processed
.PP
\f[B].\f[R] (x \[en]) \f[I]x\f[R] is output (as a signed number if
\f[I]BASE\f[R] is ten)
.PP
\f[B]<\f[R] (x1 x2 \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x1\f[R] is less than \f[I]x2\f[R] (otherwise \f[I]FALSE\f[R])
.PP
\f[B]>\f[R] (x1 x2 \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x1\f[R] is greater than \f[I]x2\f[R] (otherwise \f[I]FALSE\f[R])
.PP
\f[B]<>\f[R] (x1 x2 \[en] flag) \f[I]flag\f[R] is \f[I]TRUE\f[R] if
\f[I]x1\f[R] is not equal to \f[I]x2\f[R] (otherwise \f[I]FALSE\f[R])
.PP
\f[B]#>\f[R] (xd \[en] addr u) Make a pictured numeric string of length
\f[I]u\f[R] available at \f[I]addr\f[R]
.PP
\f[B]<#\f[R] Initialise the pictured numeric string process
.PP
\f[B]#\f[R] (ud1 \[en] ud2) Extract one (lowest) digit (by radix) from
\f[I]ud1\f[R] leaving \f[I]ud2\f[R] and add to pictured numeric string
.PP
\f[B]#S\f[R] (ud1 \[en] ud2) Add all remaining digits to pictured
numeric string - at conclusion \f[B]ud2\f[R] is zero
.PP
\f[B](\f[R] Begin a parenthesised comment (closed with \f[I])\f[R])
.PP
\f[B]?DO\f[R] (n1 n2 \[en]) Do not execute loop body if \f[I]n1\f[R] and
\f[I]n2\f[R] are equal
.PP
\f[B]?DUP\f[R] (x \[en] 0 | x x) if \f[I]x\f[R] is non-zero duplicate
\f[I]x\f[R]
.PP
\f[B]>BODY\f[R] (xt \[en] addr) \f[I]addr\f[R] returns the data space
pointer value used by \f[I]xt\f[R]
.PP
\f[B]>IN\f[R] (\[en] addr) \f[I]addr\f[R] is the address of a cell
containing the offset in characters from the start of the input buffer
to the start of the parse area
.PP
\f[B]>NUMBER\f[R] (ud1 addr1 u1 \[en] ud2 addr2 u2) Convert the string
at \f[I]addr1\f[R] of length \f[I]u1\f[R] to a number, using the current
radix.
\f[I]ud1\f[R] may be set to a non-zero number at the start and this will
be added to the converted number.
At the end \f[I]ud2\f[R] holds the converted number, \f[I]addr2\f[R]
points to the first unconverted characted and \f[I]u2\f[R] holds the
number of unconverted characters.
.PP
\f[B]>R\f[R] (x \[en]) R:(\[en]x) Move \f[I]x\f[R] from the (data) stack
to the return stack
.SH AUTHORS
Adrian McMenamin.
